#!/usr/bin/env python3

"""
Adaptive spatial array simulation: Used to create training data to test the performance of adaptive algorithms.

1. The steering vector s is formed and normalized.  
2. The jammer covariance matrix Rx_array is built by summing the contributions from each jammer (including the sinc function formulation, where np.sinc already implements sin(πx)/(πx) matching MATLAB).  
3. The square-root matrix A is computed with SciPy's fractional_matrix_power and then normalized by √2.  
4. A set of samples is generated by “coloring” standard complex Gaussian noise with A.conj().T.  
5. The eigenvalues of both the sample covariance matrix and the true covariance matrix are computed, sorted (in descending order) and plotted.  
6. The FFT is used to compute the beam patterns for the non-adaptive (using the steering vector) and adaptive (using the optimal weight vector) cases.  
7. The frequency axis is converted to an angle axis using arcsin. Vertical lines show the jammer locations.
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import fractional_matrix_power

# --------------------------------------------------------------------
# Parameters
# --------------------------------------------------------------------
N = 10 # number of elements in ULA
num_samples = 10000
d = 0.5

look_direction_deg = 20
look_direction_rad = np.deg2rad(look_direction_deg)

num_jammers = 3  # Number of jammers
jammer_pow_dB = np.array([30, 30, 30])  # Jammer powers in dB (as a J-vector)
jammer_pow_linear = 10.0 ** (jammer_pow_dB / 10) # in linear form
jammer_aoa_deg = np.array([-70, -20, 40])  # Jammer angles in degrees
jammer_aoa_rad = np.sin(np.deg2rad(jammer_aoa_deg)) * np.pi # not sure why the *pi is here
element_gain_dB = np.zeros(N) # Gains in dB for the array elements (all zeros here)
element_gain_linear = 10.0 ** (element_gain_dB / 10) # Convert array gains to linear numbers
fractional_bw = 0.1 # if this is 0, the method matches the traditional way of using array factor to simulate received signals

if True:
    # --------------------------------------------------------------------
    # Build NxN jammer covariance matrix R
    # --------------------------------------------------------------------
    R = np.zeros((N, N), dtype=complex)
    for m in range(N):
        for n in range(N):
            for j in range(num_jammers):
                total_element_gain = np.sqrt(element_gain_linear[m] * element_gain_linear[n])
                sinc_term = np.sinc(0.5 * fractional_bw * (m - n) * jammer_aoa_rad[j] / np.pi)
                exp_term = np.exp(1j * (m - n) * jammer_aoa_rad[j])
                R[m, n] += jammer_pow_linear[j] * total_element_gain * sinc_term * exp_term
    R = np.eye(N, dtype=complex) + R
    #R = np.eye(N, dtype=complex) # zero jammers

    # --------------------------------------------------------------------
    # Generate received samples
    # --------------------------------------------------------------------
    A = fractional_matrix_power(R, 0.5) # Compute the matrix square-root (effective Cholesky factorization)
    A = A / np.sqrt(2)
    X = np.zeros((N, num_samples), dtype=complex)
    for k in range(num_samples):
        noise_vec = np.random.randn(N) + 1j * np.random.randn(N) # complex noise
        X[:, k] = A.conj().T @ noise_vec
else:
    # Traditional narrowband method of adding jammers
    X = np.zeros((N, num_samples), dtype=complex)
    for j in range(num_jammers):
        s_jammer = np.exp(2j * np.pi * np.arange(N) * d * np.sin(np.deg2rad(jammer_aoa_deg[j]))).reshape(-1,1)
        tx_jammer = np.exp(2j*np.pi*(0.05*(j+1))*np.arange(num_samples)).reshape(1,-1) # put them on diff freq for good measure
        temp = s_jammer @ tx_jammer
        X += s_jammer @ tx_jammer * np.sqrt(jammer_pow_linear[j])
    # Add noise
    noise = np.random.randn(N, num_samples) + 1j * np.random.randn(N, num_samples)
    X += noise / np.sqrt(2)

# --------------------------------------------------------------------
# Plot eigenspectra (eigenvalues sorted)
# --------------------------------------------------------------------
R_est = (X @ X.conj().T) / X.shape[1] # Compute the sample covariance matrix from received samples
eigvals = np.real(np.linalg.eigvals(R_est))
eigvals_dB = 10 * np.log10(eigvals)
eigvals_sorted = np.sort(eigvals_dB)[::-1] # Sort the eigenvalues in desc order

# Compute eigenvalues of the true covariance matrix, Rx_array.
#eigvals_true = np.real(np.linalg.eigvals(R))
#eigvals_true_dB = 10 * np.log10(np.abs(eigvals_true))
#eigvals_true_sorted = np.sort(eigvals_true_dB)[::-1]

# Plot the eigenvalues
plt.figure()
plt.plot(eigvals_sorted, 'k*', label='Sampled')
#plt.plot(eigvals_true_sorted, 'r', label='True')
plt.xlabel('Eigenvalue Number', fontweight='bold', fontsize=14)
plt.ylabel('Eigenvalue, dB', fontweight='bold', fontsize=14)
plt.axis((0, N, np.min(eigvals_sorted) - 10, np.max(eigvals_sorted) + 10))
plt.grid(True)
plt.title('Eigenspectra of true & sampled jammer covariance matrix, using K = ' + str(num_samples) + ' samples')
plt.legend()


# --------------------------------------------------------------------
# Plot optimal and adaptive antenna patterns
# --------------------------------------------------------------------
nfft = 2048 # for plotting weights beam pattern

# Compute non-adaptive (conventional) weights and beam pattern
s = np.exp(2j * np.pi * np.arange(N) * d * np.sin(look_direction_rad)) # type: ignore # Create steering vector
w_conventional = s
w_conventional /= np.linalg.norm(w_conventional)  # Normalize
pattern_conventional = 20 * np.log10(np.abs(np.fft.fftshift(np.fft.fft(w_conventional, n=nfft)) / np.sqrt(N)))

# Compute MVDR weights and beam pattern FIXME THIS IS USING THE GENERATED R NOT THE CALC R BASED ON X, SO CONTRIVED!
R = np.cov(X)
w_ideal = np.linalg.inv(R) @ s
w_ideal = w_ideal / (np.conjugate(s) @ np.linalg.inv(R) @ s)
pattern_mvdr = 20 * np.log10(np.abs(np.fft.fftshift(np.fft.fft(w_ideal, n=nfft)) / np.sqrt(N)))

# Frequency axis for beam pattern using arcsin() trick
Fs = 2 * np.pi  # sample rate in Hz
faxis = np.arange(-nfft/2, nfft/2) / nfft * Fs
faxis_normalized = np.clip(faxis/np.pi, -1, 1)
faxis_physical_angle = np.rad2deg(np.arcsin(faxis_normalized))

# Plot the patterns
plt.figure(figsize=(10, 6))
plt.plot(faxis_physical_angle, pattern_conventional, 'b:', label='Non-Adaptive Pattern')
plt.plot(faxis_physical_angle, pattern_mvdr, 'black', label='Optimal Pattern')

plt.xlim([-90, 90])
plt.ylim([-80, 10])
plt.xlabel('Azimuth angle (deg)', fontsize=14)
plt.ylabel('Power, dB', fontsize=14)
#plt.title('N=' + str(N) + ' DOF, K=' + str(num_samples), fontweight='bold', fontsize=14)

# Plot vertical lines at jammer and look locations
for theta in jammer_aoa_deg:
    plt.axvline(x=theta, color='r', linestyle='--', linewidth=2)
plt.axvline(x=look_direction_deg, color='g', linestyle='--', linewidth=2)

legend_str = ['Conventional Pattern', 'MVDR Pattern']
plt.legend(legend_str, loc='upper left', frameon=False, fontsize=12)
plt.grid(True)
#plt.savefig('../_images/doa_covariance_method_1.svg', bbox_inches='tight') # 1 is fractiona_bw=0, and 2 is 0.1
plt.show()

