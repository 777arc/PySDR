#!/usr/bin/env python3

"""
Adaptive spatial array simulation: Used to create training data to test the performance of adaptive algorithms.

1. The steering vector s is formed and normalized.  
2. The jammer covariance matrix Rx_array is built by summing the contributions from each jammer (including the sinc function formulation, where np.sinc already implements sin(πx)/(πx) matching MATLAB).  
3. The square-root matrix A is computed with SciPy's fractional_matrix_power and then normalized by √2.  
4. A set of K snapshots is generated by “coloring” standard complex Gaussian noise with A.conj().T.  
5. The eigenvalues of both the sample covariance matrix and the true covariance matrix are computed, sorted (in descending order) and plotted.  
6. The FFT is used to compute the beam patterns for the non-adaptive (using the steering vector) and adaptive (using the optimal weight vector) cases.  
7. The frequency axis is converted to an angle axis using arcsin. Vertical lines show the jammer locations.
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import fractional_matrix_power

# --------------------------------------------------------------------
# Parameters
# --------------------------------------------------------------------
N = 10                         # Number of adaptive degrees of freedom (DOFs) or input channels
Kmax = int(np.floor(6 * N))    # Number of snapshots (= training-data vectors)
d = 0.5

look_direction_deg = 20
look_direction_rad = np.deg2rad(look_direction_deg)

num_jammers = 3  # Number of jammers
jammer_pow_dB = np.array([30, 30, 30])  # Jammer powers in dB (as a J-vector)
jammer_pow_linear = 10.0 ** (jammer_pow_dB / 10) # in linear form
jammer_aoa_deg = np.array([-70, -20, 40])  # Jammer angles in degrees
jammer_aoa_rad = np.sin(np.deg2rad(jammer_aoa_deg)) * np.pi # not sure why the *pi is here
element_gain_dB = np.zeros(N) # Gains in dB for the array elements (all zeros here)
element_gain_linear = 10.0 ** (element_gain_dB / 10) # Convert array gains to linear numbers
fb = 0  # Fractional bandwidth

# --------------------------------------------------------------------
# Build NxN jammer covariance matrix R
# --------------------------------------------------------------------
s = np.exp(2j * np.pi * np.arange(N) * d * np.sin(look_direction_rad)) # Create steering vector
s = s / np.linalg.norm(s)  # Normalize
R = np.zeros((N, N), dtype=complex)
for m in range(N):
    for n in range(N):
        contribution = 0
        for j in range(num_jammers):
            sinc_arg = 0.5 * fb * (m - n) * jammer_aoa_rad[j] / np.pi
            contribution += jammer_pow_linear[j] * np.sqrt(element_gain_linear[m] * element_gain_linear[n]) * np.sinc(sinc_arg) * np.exp(1j * (m - n) * jammer_aoa_rad[j])
        R[m, n] = contribution
Rx_array = np.eye(N, dtype=complex) + R
#Rx_array = np.eye(N, dtype=complex) # zero jammers

# --------------------------------------------------------------------
# Compute the matrix square-root (effective Cholesky factorization)
# --------------------------------------------------------------------
A = fractional_matrix_power(Rx_array, 0.5) # square root
A = A / np.sqrt(2)

# Compute optimum SINR
sinr_opt = np.real(np.conj(s) @ np.linalg.inv(Rx_array) @ s)

# --------------------------------------------------------------------
# Generate correlated data matrix c1 from the covariance matrix
# --------------------------------------------------------------------
num_snapshots = Kmax + 1  # total number of snapshots
c1 = np.zeros((N, num_snapshots), dtype=complex)
for k in range(num_snapshots - 1): # loop through snapshots
    noise_vec = np.random.randn(N) + 1j * np.random.randn(N) # complex noise
    c1[:, k] = A.conj().T @ noise_vec
# Last snapshot
noise_vec = np.random.randn(N) + 1j * np.random.randn(N)
c1[:, num_snapshots - 1] = A.conj().T @ noise_vec

# --------------------------------------------------------------------
# Plot eigenspectra (eigenvalue spectra)
# --------------------------------------------------------------------
sample_cov = (c1 @ c1.conj().T) / c1.shape[1] # Compute the sample covariance matrix from the data and its eigenvalues
eig_sample = np.real(np.linalg.eigvals(sample_cov))
eig_sample_dB = 10 * np.log10(eig_sample)
eig_sample_sorted = np.sort(eig_sample_dB)[::-1] # Sort the eigenvalues in desc order

# Compute eigenvalues of the true covariance matrix, Rx_array.
eig_true = np.real(np.linalg.eigvals(Rx_array))
eig_true_dB = 10 * np.log10(np.abs(eig_true))
eig_true_sorted = np.sort(eig_true_dB)[::-1]

# Plot the eigenvalues
plt.figure()
plt.plot(eig_sample_sorted, 'k*', label='Sampled')
plt.plot(eig_true_sorted, 'r', label='True')
plt.xlabel('Eigenvalue Number', fontweight='bold', fontsize=14)
plt.ylabel('Eigenvalue, dB', fontweight='bold', fontsize=14)
plt.axis((0, N, np.min(eig_sample_sorted) - 10, np.max(eig_sample_sorted) + 10))
plt.grid(True)
plt.title('Eigenspectra of true & sampled jammer covariance matrix, using K = ' + str(Kmax) + ' samples')
plt.legend()


# --------------------------------------------------------------------
# Plot optimal and adaptive antenna patterns
# --------------------------------------------------------------------
nfft = 2048 # for plotting weights beam pattern

# Compute non-adaptive (conventional) weights and beam pattern
w_conventional = s
pattern_conventional = 20 * np.log10(np.abs(np.fft.fftshift(np.fft.fft(w_conventional, n=nfft)) / np.sqrt(N)))

# Compute MVDR weights and beam pattern
w_ideal = np.linalg.inv(Rx_array) @ s
w_ideal = w_ideal / (np.conjugate(s) @ np.linalg.inv(Rx_array) @ s)
pattern_mvdr = 20 * np.log10(np.abs(np.fft.fftshift(np.fft.fft(w_ideal, n=nfft)) / np.sqrt(N)))

# Frequency axis for beam pattern using arcsin() trick
Fs = 2 * np.pi  # sample rate in Hz
faxis = np.arange(-nfft/2, nfft/2) / nfft * Fs
faxis_normalized = np.clip(faxis/np.pi, -1, 1)
faxis_physical_angle = np.rad2deg(np.arcsin(faxis_normalized))

# Plot the patterns
plt.figure(figsize=(10, 6))
plt.plot(faxis_physical_angle, pattern_conventional, 'b:', label='Non-Adaptive Pattern')
plt.plot(faxis_physical_angle, pattern_mvdr, 'black', label='Optimal Pattern')

plt.xlim([-90, 90])
plt.ylim([-80, 10])
plt.xlabel('Azimuth angle (deg)', fontweight='bold', fontsize=14)
plt.ylabel('Power, dB', fontweight='bold', fontsize=14)
plt.title('N=' + str(N) + ' DOF, K=' + str(Kmax) + ', SINR_opt= ' + str(10 * np.log10(sinr_opt)),  fontweight='bold', fontsize=14)

# Plot vertical lines at jammer and look locations
for theta in jammer_aoa_deg:
    plt.axvline(x=theta, color='r', linestyle='--', linewidth=2)
plt.axvline(x=look_direction_deg, color='g', linestyle='--', linewidth=2)

legend_str = ['Non-Adaptive Pattern', 'Optimal Pattern']
plt.legend(legend_str, loc='lower left', frameon=False, fontsize=12)
plt.grid(True)
plt.show()
